// Package wpsapi contains the types for schema 'del'.
// i say package is wpsapi
package wpsapi

// Code generated by xo. DO NOT EDIT.

import (
	"errors"
	"time"
)

// Comment represents a row from '` + GetTableName("comments") + `'.
type Comment struct {
	CommentID          uint64    `json:"comment_ID"`           // comment_ID
	CommentPostID      uint64    `json:"comment_post_ID"`      // comment_post_ID
	CommentAuthor      string    `json:"comment_author"`       // comment_author
	CommentAuthorEmail string    `json:"comment_author_email"` // comment_author_email
	CommentAuthorURL   string    `json:"comment_author_url"`   // comment_author_url
	CommentAuthorIP    string    `json:"comment_author_IP"`    // comment_author_IP
	CommentDate        time.Time `json:"comment_date"`         // comment_date
	CommentDateGmt     time.Time `json:"comment_date_gmt"`     // comment_date_gmt
	CommentContent     string    `json:"comment_content"`      // comment_content
	CommentKarma       int       `json:"comment_karma"`        // comment_karma
	CommentApproved    string    `json:"comment_approved"`     // comment_approved
	CommentAgent       string    `json:"comment_agent"`        // comment_agent
	CommentType        string    `json:"comment_type"`         // comment_type
	CommentParent      uint64    `json:"comment_parent"`       // comment_parent
	UserID             uint64    `json:"user_id"`              // user_id

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Comment exists in the database.
func (c *Comment) Exists() bool {
	return c._exists
}

// Deled provides information if the Comment has been deled from the database.
func (c *Comment) Deled() bool {
	return c._deleted
}

// Insert inserts the Comment to the database.
func (c *Comment) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if c._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	var sqlstr = `INSERT INTO ` + GetTableName("comments") + ` (` +
		`comment_post_ID, comment_author, comment_author_email, comment_author_url, comment_author_IP, comment_date, comment_date_gmt, comment_content, comment_karma, comment_approved, comment_agent, comment_type, comment_parent, user_id` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, c.CommentPostID, c.CommentAuthor, c.CommentAuthorEmail, c.CommentAuthorURL, c.CommentAuthorIP, c.CommentDate, c.CommentDateGmt, c.CommentContent, c.CommentKarma, c.CommentApproved, c.CommentAgent, c.CommentType, c.CommentParent, c.UserID)
	res, err := db.Exec(sqlstr, c.CommentPostID, c.CommentAuthor, c.CommentAuthorEmail, c.CommentAuthorURL, c.CommentAuthorIP, c.CommentDate, c.CommentDateGmt, c.CommentContent, c.CommentKarma, c.CommentApproved, c.CommentAgent, c.CommentType, c.CommentParent, c.UserID)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	c.CommentID = uint64(id)
	c._exists = true

	return nil
}

// Update updates the Comment in the database.
func (c *Comment) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !c._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if c._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	var sqlstr = `UPDATE ` + GetTableName("comments") + ` SET ` +
		`comment_post_ID = ?, comment_author = ?, comment_author_email = ?, comment_author_url = ?, comment_author_IP = ?, comment_date = ?, comment_date_gmt = ?, comment_content = ?, comment_karma = ?, comment_approved = ?, comment_agent = ?, comment_type = ?, comment_parent = ?, user_id = ?` +
		` WHERE comment_ID = ?`

	// run query
	XOLog(sqlstr, c.CommentPostID, c.CommentAuthor, c.CommentAuthorEmail, c.CommentAuthorURL, c.CommentAuthorIP, c.CommentDate, c.CommentDateGmt, c.CommentContent, c.CommentKarma, c.CommentApproved, c.CommentAgent, c.CommentType, c.CommentParent, c.UserID, c.CommentID)
	_, err = db.Exec(sqlstr, c.CommentPostID, c.CommentAuthor, c.CommentAuthorEmail, c.CommentAuthorURL, c.CommentAuthorIP, c.CommentDate, c.CommentDateGmt, c.CommentContent, c.CommentKarma, c.CommentApproved, c.CommentAgent, c.CommentType, c.CommentParent, c.UserID, c.CommentID)
	return err
}

// Save saves the Comment to the database.
func (c *Comment) Save(db XODB) error {
	if c.Exists() {
		return c.Update(db)
	}

	return c.Insert(db)
}

// Delete deletes the Comment from the database.
func (c *Comment) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !c._exists {
		return nil
	}

	// if deleted, bail
	if c._deleted {
		return nil
	}

	// sql query
	var sqlstr = `DELETE FROM ` + GetTableName("comments") + ` WHERE comment_ID = ?`

	// run query
	XOLog(sqlstr, c.CommentID)
	_, err = db.Exec(sqlstr, c.CommentID)
	if err != nil {
		return err
	}

	// set deleted
	c._deleted = true

	return nil
}

//{ {- $table := (schema .Schema .Type.Table.TableName) -} }// CommentsByCommentApprovedCommentDateGmt retrieves a row from '` + GetTableName("comments") + `' as a Comment.
//
// Generated from index 'comment_approved_date_gmt'.
func CommentsByCommentApprovedCommentDateGmt(db XODB, commentApproved string, commentDateGmt time.Time) ([]*Comment, error) {
	var err error

	// sql query
	var sqlstr = `SELECT ` +
		`comment_ID, comment_post_ID, comment_author, comment_author_email, comment_author_url, comment_author_IP, comment_date, comment_date_gmt, comment_content, comment_karma, comment_approved, comment_agent, comment_type, comment_parent, user_id ` +
		`FROM ` + GetTableName("comments") + ` ` +
		`WHERE comment_approved = ? AND comment_date_gmt = ?`

	// run query
	XOLog(sqlstr, commentApproved, commentDateGmt)
	q, err := db.Query(sqlstr, commentApproved, commentDateGmt)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Comment{}
	for q.Next() {
		c := Comment{
			_exists: true,
		}

		// scan
		err = q.Scan(&c.CommentID, &c.CommentPostID, &c.CommentAuthor, &c.CommentAuthorEmail, &c.CommentAuthorURL, &c.CommentAuthorIP, &c.CommentDate, &c.CommentDateGmt, &c.CommentContent, &c.CommentKarma, &c.CommentApproved, &c.CommentAgent, &c.CommentType, &c.CommentParent, &c.UserID)
		if err != nil {
			return nil, err
		}

		res = append(res, &c)
	}

	return res, nil
}

//{ {- $table := (schema .Schema .Type.Table.TableName) -} }// CommentsByCommentAuthorEmail retrieves a row from '` + GetTableName("comments") + `' as a Comment.
//
// Generated from index 'comment_author_email'.
func CommentsByCommentAuthorEmail(db XODB, commentAuthorEmail string) ([]*Comment, error) {
	var err error

	// sql query
	var sqlstr = `SELECT ` +
		`comment_ID, comment_post_ID, comment_author, comment_author_email, comment_author_url, comment_author_IP, comment_date, comment_date_gmt, comment_content, comment_karma, comment_approved, comment_agent, comment_type, comment_parent, user_id ` +
		`FROM ` + GetTableName("comments") + ` ` +
		`WHERE comment_author_email = ?`

	// run query
	XOLog(sqlstr, commentAuthorEmail)
	q, err := db.Query(sqlstr, commentAuthorEmail)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Comment{}
	for q.Next() {
		c := Comment{
			_exists: true,
		}

		// scan
		err = q.Scan(&c.CommentID, &c.CommentPostID, &c.CommentAuthor, &c.CommentAuthorEmail, &c.CommentAuthorURL, &c.CommentAuthorIP, &c.CommentDate, &c.CommentDateGmt, &c.CommentContent, &c.CommentKarma, &c.CommentApproved, &c.CommentAgent, &c.CommentType, &c.CommentParent, &c.UserID)
		if err != nil {
			return nil, err
		}

		res = append(res, &c)
	}

	return res, nil
}

//{ {- $table := (schema .Schema .Type.Table.TableName) -} }// CommentsByCommentDateGmt retrieves a row from '` + GetTableName("comments") + `' as a Comment.
//
// Generated from index 'comment_date_gmt'.
func CommentsByCommentDateGmt(db XODB, commentDateGmt time.Time) ([]*Comment, error) {
	var err error

	// sql query
	var sqlstr = `SELECT ` +
		`comment_ID, comment_post_ID, comment_author, comment_author_email, comment_author_url, comment_author_IP, comment_date, comment_date_gmt, comment_content, comment_karma, comment_approved, comment_agent, comment_type, comment_parent, user_id ` +
		`FROM ` + GetTableName("comments") + ` ` +
		`WHERE comment_date_gmt = ?`

	// run query
	XOLog(sqlstr, commentDateGmt)
	q, err := db.Query(sqlstr, commentDateGmt)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Comment{}
	for q.Next() {
		c := Comment{
			_exists: true,
		}

		// scan
		err = q.Scan(&c.CommentID, &c.CommentPostID, &c.CommentAuthor, &c.CommentAuthorEmail, &c.CommentAuthorURL, &c.CommentAuthorIP, &c.CommentDate, &c.CommentDateGmt, &c.CommentContent, &c.CommentKarma, &c.CommentApproved, &c.CommentAgent, &c.CommentType, &c.CommentParent, &c.UserID)
		if err != nil {
			return nil, err
		}

		res = append(res, &c)
	}

	return res, nil
}

//{ {- $table := (schema .Schema .Type.Table.TableName) -} }// CommentsByCommentParent retrieves a row from '` + GetTableName("comments") + `' as a Comment.
//
// Generated from index 'comment_parent'.
func CommentsByCommentParent(db XODB, commentParent uint64) ([]*Comment, error) {
	var err error

	// sql query
	var sqlstr = `SELECT ` +
		`comment_ID, comment_post_ID, comment_author, comment_author_email, comment_author_url, comment_author_IP, comment_date, comment_date_gmt, comment_content, comment_karma, comment_approved, comment_agent, comment_type, comment_parent, user_id ` +
		`FROM ` + GetTableName("comments") + ` ` +
		`WHERE comment_parent = ?`

	// run query
	XOLog(sqlstr, commentParent)
	q, err := db.Query(sqlstr, commentParent)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Comment{}
	for q.Next() {
		c := Comment{
			_exists: true,
		}

		// scan
		err = q.Scan(&c.CommentID, &c.CommentPostID, &c.CommentAuthor, &c.CommentAuthorEmail, &c.CommentAuthorURL, &c.CommentAuthorIP, &c.CommentDate, &c.CommentDateGmt, &c.CommentContent, &c.CommentKarma, &c.CommentApproved, &c.CommentAgent, &c.CommentType, &c.CommentParent, &c.UserID)
		if err != nil {
			return nil, err
		}

		res = append(res, &c)
	}

	return res, nil
}

//{ {- $table := (schema .Schema .Type.Table.TableName) -} }// CommentsByCommentPostID retrieves a row from '` + GetTableName("comments") + `' as a Comment.
//
// Generated from index 'comment_post_ID'.
func CommentsByCommentPostID(db XODB, commentPostID uint64) ([]*Comment, error) {
	var err error

	// sql query
	var sqlstr = `SELECT ` +
		`comment_ID, comment_post_ID, comment_author, comment_author_email, comment_author_url, comment_author_IP, comment_date, comment_date_gmt, comment_content, comment_karma, comment_approved, comment_agent, comment_type, comment_parent, user_id ` +
		`FROM ` + GetTableName("comments") + ` ` +
		`WHERE comment_post_ID = ?`

	// run query
	XOLog(sqlstr, commentPostID)
	q, err := db.Query(sqlstr, commentPostID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Comment{}
	for q.Next() {
		c := Comment{
			_exists: true,
		}

		// scan
		err = q.Scan(&c.CommentID, &c.CommentPostID, &c.CommentAuthor, &c.CommentAuthorEmail, &c.CommentAuthorURL, &c.CommentAuthorIP, &c.CommentDate, &c.CommentDateGmt, &c.CommentContent, &c.CommentKarma, &c.CommentApproved, &c.CommentAgent, &c.CommentType, &c.CommentParent, &c.UserID)
		if err != nil {
			return nil, err
		}

		res = append(res, &c)
	}

	return res, nil
}

//{ {- $table := (schema .Schema .Type.Table.TableName) -} }// CommentByCommentID retrieves a row from '` + GetTableName("comments") + `' as a Comment.
//
// Generated from index 'comments_comment_ID_pkey'.
func CommentByCommentID(db XODB, commentID uint64) (*Comment, error) {
	var err error

	// sql query
	var sqlstr = `SELECT ` +
		`comment_ID, comment_post_ID, comment_author, comment_author_email, comment_author_url, comment_author_IP, comment_date, comment_date_gmt, comment_content, comment_karma, comment_approved, comment_agent, comment_type, comment_parent, user_id ` +
		`FROM ` + GetTableName("comments") + ` ` +
		`WHERE comment_ID = ?`

	// run query
	XOLog(sqlstr, commentID)
	c := Comment{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, commentID).Scan(&c.CommentID, &c.CommentPostID, &c.CommentAuthor, &c.CommentAuthorEmail, &c.CommentAuthorURL, &c.CommentAuthorIP, &c.CommentDate, &c.CommentDateGmt, &c.CommentContent, &c.CommentKarma, &c.CommentApproved, &c.CommentAgent, &c.CommentType, &c.CommentParent, &c.UserID)
	if err != nil {
		return nil, err
	}

	return &c, nil
}
